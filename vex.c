#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    IR_Right_raw,  sensorReflection)
#pragma config(Sensor, in2,    IR_Left_raw,    sensorReflection)
#pragma config(Sensor, dgtl1,  switch_front,   sensorTouch)
#pragma config(Sensor, dgtl2,  switch_left,    sensorTouch)
#pragma config(Sensor, dgtl3,  switch_right,   sensorTouch)
#pragma config(Sensor, dgtl4,  button1,        sensorTouch)
#pragma config(Sensor, dgtl5,  LED1,           sensorDigitalOut)
#pragma config(Sensor, dgtl6,  LED2,           sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           M_Drive,       tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           M_Crane,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          M_Steer,       tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
	\\\ GUIDE TO MILESTONE 3 FUNCTIONS ///

	CTRL + F to find keywords in code, given in CAPS


1)	Find beacon and face it:
			switch(State) = Searching 					//KEYWORD M3SEARCHING (search for this keyword)

2)	Indicate robot is facing beacon: turns LED1 on
			-	beaconDetect()										//KEYWORD M3DETECT (search for this keyword)
					*sets seesBeacon = true
			- monitorInput()										//KEYWORD M3LED1 (search for this keyword)
					*if (seesBeacon == true) then turn LED1 ON

3)	Indicate robot is ready for cable connection: LED2 turns on, crane arm lowers then raises

			- switch(State) = Cable_Connection	//KEYWORD M3Cable (search for this keyword)
					*lowers then raises crane arm.
					*only triggers when seesBeacon == true AND front switch is pushed

			- LED2 turns ON											//KEYWORD M3LED2 (search for this keyword)

4)	Indicate robot has hit a wall
			- switch(State) = Backward 					//KEYWORD M3BACKWARD (search for this keyword)
					*backs up the direction it came until no more trigger switches are pressed

*/

const int IR_SENSOR_THRESHOLD = 90; 			 // (change in IR values
const int IR_SENSOR_THRESHOLD_CLOSE = 500;

//	Motor speed values
const int M_DRIVE_SPEED_XSLOW = 25;
const int M_DRIVE_SPEED_SLOW 	= 35;
const int M_STEER_SPEED_FAST 	= 45; //WIP

const int M_STEER_SPEED 			= 25;
const int M_STEER_SPEED_SLOW	= 15;

const int M_CRANE_SPEED_SLOW	= 20;
const int M_CRANE_SPEED_FAST	= 30;

const int M_STEER_ROTATION_MAX = 60; 		// Max rotation for back wheel (Was 66)
const int M_DRIVE_ROTATION_180 = 1800; 	// Robot has driven around in semi-circle ~180 degrees

// LED light control values.
const int OFF = 0;
const int ON  = 1;

bool switch_front_pushed 	= false;
bool switch_left_pushed 	= false;
bool switch_right_pushed 	= false;
bool button1_pushed 			= false; //trigger to start program

//IR sensor returns from beaconDetect()
bool seesBeacon = false;
bool seesBeacon_close = false;

int M_Drive_Encoder 	= 0;
int M_Steer_Rotation 	= 0;

void initLightStatus(){
	SensorValue(LED1) = OFF;
	SensorValue(LED2) = OFF;
}

//Values for IR sensors
int diff_IR_left  = 0; //difference between min and max
int max_IR_left   = 0;
int min_IR_left   = 4096;

int diff_IR_right = 0; // difference between min and max
int max_IR_right  = 0;
int min_IR_right  = 4096;

int IR_Left = 0; //testing purposes
int IR_Right = 0; //testing purposes


//KEYWORD M3DETECT
void beaconDetect(){
		IR_Left = SensorValue(IR_Left_raw);
		IR_Right = SensorValue(IR_Right_raw);

		if(time1[T1] > 100){
				//100 msecs have elapsed
				diff_IR_left = max_IR_left - min_IR_left;
				diff_IR_right = max_IR_right - min_IR_right;

				//reset values
				max_IR_left = 0;
				min_IR_left = 4096;

				max_IR_right = 0;
				min_IR_right = 4096;
				clearTimer(T1);
		}
		if(time1[T1] < 100) {

			//check for new min/max values
			if (SensorValue(IR_Left_raw) < min_IR_left){
				min_IR_left = SensorValue(IR_Left_raw);
			}else if(SensorValue(IR_Left_raw) > max_IR_left){
				max_IR_left = SensorValue(IR_Left_raw);
			}

			if (SensorValue(IR_Right_raw) < min_IR_right){
				min_IR_right = SensorValue(IR_Right_raw);
			}else if(SensorValue(IR_Right_raw) > max_IR_right){
				max_IR_right = SensorValue(IR_Right_raw);
			}

		}


		//check if change in values is bigger than threshold, for both sensors
		if (	 (diff_IR_left < IR_SENSOR_THRESHOLD) || (diff_IR_right < IR_SENSOR_THRESHOLD)){
			seesBeacon = false;
		} else if ( (diff_IR_left >= IR_SENSOR_THRESHOLD) && (diff_IR_right >= IR_SENSOR_THRESHOLD) ) {
			seesBeacon = true;
		}

		// same check, for closer threshold
		if ( (diff_IR_left < IR_SENSOR_THRESHOLD_CLOSE) || (diff_IR_right < IR_SENSOR_THRESHOLD_CLOSE)){
			seesBeacon_close = false;
		} else if ( (diff_IR_left > IR_SENSOR_THRESHOLD_CLOSE) && (diff_IR_right > IR_SENSOR_THRESHOLD_CLOSE) ) {
			seesBeacon_close = true;
		}
}
void monitorInput()
{
	beaconDetect();
	M_Drive_Encoder = getMotorEncoder(M_Drive);
	M_Steer_Rotation = getMotorEncoder(M_Steer);

	//inputs
  if(SensorValue(button1) && !button1_pushed){
    button1_pushed = true; 				//Starts program
  }
  if(SensorValue(switch_front) && !switch_front_pushed){
    switch_front_pushed = true; 	//front switch pressed
  }
  if(SensorValue(switch_left) && !switch_left_pushed){
    switch_left_pushed = true; 		//left side switch pressed
  }
  if(SensorValue(switch_right) && !switch_right_pushed){
    switch_right_pushed = true; 	//right side switch pressed
  }

  //LEDs

  //KEYWORD M3LED1
  if ( (seesBeacon) && (SensorValue(LED1) == OFF) ){
  	SensorValue(LED1) = ON; 	// ON if facing beacon

  } else if ( (!seesBeacon) && (SensorValue(LED1) == ON) ){
  	SensorValue(LED1) = OFF; 	// OFF if not facing beacon
  }

	//KEYWORD M3LED2
  if ( switch_front_pushed && (SensorValue(LED2) == OFF)  ){
  	SensorValue(LED2) = ON;	  //ON if facing beacon and front switch is pushed

  } else if ( (!switch_front_pushed ) && (SensorValue(LED2) == ON)){
  	SensorValue(LED2) = OFF;  //OFF if not facing beacon or front switch is not pushed
  }


} //monitorInput()

void setAllMotors(int value){ //Easy way to shut off all motors
	motor[M_Drive] = value;
	motor[M_Crane] = value;
	motor[M_Steer] = value;
} //setAllMotors()

/*
Useful values for motors on robot
35 - slow drive
20 - slow crane
20 - good back wheel speed
*/

typedef enum R_State{
	Stopped = 0,
	Searching,
	Forward_Fast,
	Forward_Slow,
	Backward,
	Cable_Connection
}R_State;

R_State State = Stopped;

int searchingState = 0;
/*
	0 = not searching
	1 = turning left
	2 = turning right
	3 = returning to centre
	4 = reset back wheel
*/
void resetSteerWheel(){
	//reset back wheel

	int a = M_Steer_Rotation; //initial value
	int b = M_Steer_Rotation; //after value
	// |a-b| change in turning - used to check if robot is not turning
	while(M_Steer_Rotation > 5 || M_Steer_Rotation < -5) {
		clearTimer(T2);
		monitorInput();
		//motor(M_Steer) = -M_STEER_SPEED_SLOW;
		b = M_Steer_Rotation;
		if( M_Steer_Rotation > 3) {
			motor(M_Steer) = -M_STEER_SPEED_SLOW;
		}
		while (M_Steer_Rotation > 3){ //while back wheel is turned right
			monitorInput();
			a = M_Steer_Rotation;
			if ( (a-b) < 10 && time1[T2] > 150){ //if stuck

				if( (a-b) < 10 && time1[T2] > 750){
					motor(M_Steer) = -M_STEER_SPEED_FAST; //use even more power
				}else {
					motor(M_Steer) = -M_STEER_SPEED; //use more power
				}
			} else {
				motor(M_Steer) = -M_STEER_SPEED_SLOW;
			}

		}
		motor(M_Steer) = 0;
		delay(200);

		monitorInput();
		clearTimer(T2);
		a = M_Steer_Rotation; //initial value
		b = M_Steer_Rotation; //after value
		// |a-b| -> change in turning - used to check if robot is not turning

		if( M_Steer_Rotation < -3) {
			motor(M_Steer) = M_STEER_SPEED_SLOW;
		}
		while (M_Steer_Rotation < -3){ //while back wheel is turned left
			monitorInput();

			a = M_Steer_Rotation;
			if ( (b-a) < 10 && time1[T2] > 150){ //if stuck

				if( (b-a) < 10 && time1[T2] > 750){//if really stuck
					motor(M_Steer) = M_STEER_SPEED_FAST; //use even more power
				}else {
					motor(M_Steer) = M_STEER_SPEED; //use more power
				}

				motor(M_Steer) = M_STEER_SPEED; //use more power
			} else {
				motor(M_Steer) = M_STEER_SPEED_SLOW; //slow back down
			}
		}
		clearTimer(T2);
		motor(M_Steer) = 0;
		delay(200);
		monitorInput();
	}
	delay(200);
	monitorInput();
}

task main()
{
	initLightStatus();

	bool hasSearchedLeft = false;
	/*
		false = hasn't searched OR has only searched right
		true = has searched left
	*/
	bool craneIsDown = false;

	bool program_Running = false;
	resetMotorEncoder(M_Steer);
	resetMotorEncoder(M_Drive);
	while(1){

		monitorInput(); //Get values from sensors

		switch(State){
			case Stopped:
				setAllMotors(0);
				resetMotorEncoder(M_Drive);
				searchingState = 0;

				monitorInput();

				delay(200);
				monitorInput();

				if ( button1_pushed || program_Running){ //Determine if the program is already running or if it is waiting for a button press
					button1_pushed = false;
					program_Running = true;
					State = Searching;
				} //if

				if(switch_left_pushed || switch_right_pushed){ //back up if hit wall
					switch_left_pushed = false;
					switch_right_pushed = false;
					State = Backward;
				} //if

				if(switch_front_pushed) { 	//check if robot hit wall or if it hit the beacon
					switch_front_pushed = false;

					if ( seesBeacon ){
						//KEYWORD M3Cable (press NEXT to go to State = Cable_Connection)
						State = Cable_Connection;
						continue;
					} else {
						State = Backward;
					}//if
				}//if


			break;

			//KEYWORD M3SEARCHING
			case Searching: //turns left 180 degrees looking for beacon, if doesn't find, it returns to centre, then turns right 180 degrees. If doesn't find, it returns to centre and tries again.
				monitorInput();
				switch(searchingState){
					case 0: //not searching
						setAllMotors(0);
						if(M_Drive_Encoder > 60){ //checks if robot needs to be reset
								searchingState = 3; //reset displacement

						}else{ //robot is about to search

							if(hasSearchedLeft == true) { //if already searched left
									searchingState = 2; //search right
							}else{
									searchingState = 1; //search left
							}
						}
					break;

					case 1: //turning left
						while (M_Steer_Rotation > -M_STEER_ROTATION_MAX){
							monitorInput();
							motor(M_Steer) = -M_STEER_SPEED;
						}
						motor(M_Steer) = 0;
						motor(M_Drive) = M_DRIVE_SPEED_SLOW;
						hasSearchedLeft = true;
					break;

					case 2: //turning right
						while (M_Steer_Rotation < M_STEER_ROTATION_MAX){
							monitorInput();
							motor(M_Steer) = M_STEER_SPEED;
						}
						motor(M_Steer) = 0;
						motor(M_Drive) = M_DRIVE_SPEED_SLOW;
						hasSearchedLeft = false;
					break;

					case 3: //return to centre
						while(M_Drive_Encoder >= 15){ //return to start
							monitorInput();
							motor(M_Drive) = -M_DRIVE_SPEED_SLOW;
							if(seesBeacon){
								resetMotorEncoder(M_Drive);
								break;
							}
						}
						motor(M_Drive) = 0;
						delay(200);
						monitorInput();
						searchingState = 4; //reset back wheel
					break;

					case 4: //reset back wheel
						resetSteerWheel();

						searchingState = 0;

						if ( seesBeacon ){
						//IR sensors have close to the same value AND IR sensors value is above threshold
							State = Forward_Fast;
						}
					break;

					default:
						searchingState = 0;
					break;
				} //switch(SearchingState)

				monitorInput();

				if ((M_Drive_Encoder >= M_DRIVE_ROTATION_180) && (searchingState != 3)){ //if robot has done 180 degrees
					searchingState = 0;
					motor(M_Drive) = 0;
				}

				if ( seesBeacon ){
					//delay(80);
					monitorInput();

					motor(M_Drive) = 0;
					searchingState = 4; //reset back wheel, then will change state to Forward_Fast
				}

				if(diff_IR_left > diff_IR_right){
					hasSearchedLeft = false;
				}
				if(diff_IR_left < diff_IR_right){
					hasSearchedLeft = true;
				}

				if (State != Searching){ //reset when leave function
					searchingState = 0;
					resetMotorEncoder(M_Drive);
				}
			break;

			case Forward_Fast:
				if(!seesBeacon){
					//If robot is driving forward but goes off track of beacon, STOP
					State = Stopped;
				}

				if (seesBeacon_close){
						State = Forward_Slow;
						break;
				}
				//motor(M_Drive) = M_DRIVE_SPEED_FAST;
				motor(M_Drive) = M_DRIVE_SPEED_SLOW; //WIP
			break;

			case Forward_Slow:
				motor(M_Drive) = M_DRIVE_SPEED_XSLOW;
				if(!seesBeacon){
					//If robot is driving forward but goes off track of beacon, STOP
					State = Stopped;
				}
			break;

			case Backward:
				//reverse
				while(M_Drive_Encoder > -100){
					motor(M_Drive) = -M_DRIVE_SPEED_XSLOW;
					monitorInput();
				}
				if(M_Drive_Encoder > -105){
					motor(M_Drive) = 0;
					monitorInput();
					resetSteerWheel();
					motor(M_Drive) = -M_DRIVE_SPEED_SLOW;
					delay(100);
					monitorInput();
				}

				motor(M_Drive) = -M_DRIVE_SPEED_SLOW;

				if(M_Drive_Encoder < -450){ //triggers when it has looped long enough
					motor(M_Drive) = 0;
					monitorInput();

					resetMotorEncoder(M_Drive);

					if(craneIsDown){
						State = Cable_Connection;	//return to Cable_Connection
					} else if (craneIsDown == false) {
						State = Stopped; // Finished backing away from object that triggered
						resetSteerWheel();

						switch_front_pushed = false;
						switch_left_pushed = false;
						switch_right_pushed = false;
						monitorInput();
					}

				}
			break;

			case Cable_Connection:
			//KEYWORD M3Cable
				motor(M_Drive) = 0;
				if(craneIsDown == false){
					motor(M_Crane) = -M_CRANE_SPEED_SLOW; //lowers crane
					delay(300);
					motor(M_Crane) = 0;

					monitorInput();
					craneIsDown = true;
					State = Backward; //Backs up, then when it is finished, it comes back here to raise crane

				} else {
					motor(M_Crane) = M_CRANE_SPEED_FAST; //raise crane back up, takes more power
					delay(300);
					monitorInput();
					motor(M_Crane) = 0;

					craneIsDown = false;
					program_Running = false; //program is finished, ready to go again
					State = Stopped; //reset
				}
			break;

			//break;
			default:
				State = Stopped;
			break;
		} //switch(State)

		monitorInput();
		if( (switch_left_pushed || switch_right_pushed || switch_front_pushed) && (State != Stopped) && (State != Backward) && (State != Cable_Connection)){
				//when a switch is triggered, stop and back up
				//not triggered when state is backward so that the robot can move away without infinite loop
				State = Stopped;
		}

	} //while

}//main
